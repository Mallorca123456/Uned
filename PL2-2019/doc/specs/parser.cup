package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;



// Declaración del código de usuario

action code   {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory();

	public void openScope(String scopeName) {
	    ScopeIF scope = scopeManager.openScope(scopeName);
        syntaxErrorManager.syntaxInfo("ClOpense " + scope);
	}

    public ScopeIF getCurrentScope(){
        return scopeManager.getCurrentScope();
    }

	public void closeCurrentScope() {
	    ScopeIF scope = scopeManager.getCurrentScope();
        scopeManager.closeScope();
        syntaxErrorManager.syntaxInfo("Close " + scope);
	}

	public void checkSymbolDoesNotExists(String identifier){
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF symbolTable = scope.getSymbolTable();
	    if(symbolTable.containsSymbol(identifier)){
            syntaxErrorManager.syntaxError("Identificador ya utilizado");
		}
	}

	public void addSymbol(String identifier, SymbolIF symbol){
	    ScopeIF scope = scopeManager.getCurrentScope();
        SymbolTableIF symbolTable = scope.getSymbolTable();
        symbolTable.addSymbol(identifier, symbol);
        syntaxErrorManager.syntaxInfo("Added symbol " + identifier);
	}

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}


//
// Declaración de terminales

//
terminal Token IDENTIFICADOR;
terminal Token INTEGER, BOOLEAN, STRING;
terminal Token ARRAY, OF;
terminal Token MODULE, BEGIN, END, PROCEDURE, RETURN;
terminal Token OR, NOT;
terminal Token CONST, TYPE, VAR;
terminal Token IF, ELSE, THEN, DO, FOR, TO;
terminal Token WRITESTRING, WRITEINT, WRITELN;

terminal Token PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;
terminal Token PUNTOPUNTO, COMA, PUNTOYCOMA, DOSPUNTOS, IGUAL;
terminal Token MINUS, PRODUCTO, MAYOR;
terminal Token DOSPUNTOSIGUAL;

terminal Token ENTERO;
terminal Token TRUE, FALSE;

//
// Declaración de no terminales
//
non terminal                     program;
non terminal   Axiom		     axiom;

non terminal   CabModule         cabModule;
non terminal   Cuerpo            cuerpo;

non terminal   StmConstantes     stmConstantes;
non terminal   StmTipos          stmTipos;
non terminal   StmVar            stmVar;
non terminal   StmSubprogram     stmSubprogram;

non terminal   SentConst         sentConst;
non terminal   ExpConst          expConst;
non terminal   ValorConst        valorConst;

non terminal   SentTipo          sentTipo;
non terminal   ExpTipo           expTipo;

non terminal   SentVar           sentVar;
non terminal   ExpVar            expVar;
non terminal   CadIdVar          cadIdVar;
non terminal   TipoVar           tipoVar;

non terminal   CabProcedure      cabProcedure;
non terminal   TipoRetorno       tipoRetorno;
non terminal   ProcParenParam    procParenParam;
non terminal   ProcListParam     procListParam;
non terminal   ProcParam         procParam;

non terminal   Sentencias        sentencias;
non terminal   ListSentencia     listSentencia;
non terminal   Sentencia         sentencia;

non terminal   Expresion         expresion;
non terminal   ExpArit           exprArit;
non terminal   ExprLogica        exprLogica;
non terminal   Variables         variables;

non terminal   SentProcedure     sentProcedure;
non terminal   ParFuncion        parFuncion;
non terminal   Parametros        parametros;

non terminal   SentAsign         sentAsign;
non terminal   SentReturn        sentReturn;
non terminal   SentIf            sentIf;
non terminal   SentElse          sentElse;
non terminal   SentFor           sentFor;

non terminal   SWriteString      sWriteString;
non terminal   SWriteInt         sWriteInt;
non terminal   SWriteLn          sWriteLn;

non terminal   IdArray           idArray;
non terminal   IntOBool          intOBool;
non terminal   EntOId            entOid;
non terminal   VBooleano         vBooleano;

// Declaración de relaciones de precedencia
precedence nonassoc MAYOR, IGUAL;
precedence left     MINUS, OR;
precedence left     PRODUCTO;
precedence right    NOT;

precedence left     PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;

//
// Declaración de reglas de producción

start with program;

program ::= 
  {: 
      syntaxErrorManager.syntaxInfo("Starting parsing...");

  :}
  axiom:ax
  {:
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.

  		syntaxErrorManager.syntaxInfo("Parsing process ended.");
  :};


axiom ::= cabModule:cabModule
          cuerpo:cuerpo
          | cabModule error;

// Cabecera de los modulos
cabModule     ::= MODULE IDENTIFICADOR:identificador PUNTOYCOMA
                  {:
                   openScope("MODULE_" + identificador.getLexema());
                   RESULT = new CabModule(identificador.getLexema());
                  :}
                | MODULE error;

// Cuerpo de los modulos y comun para procedimientos y funciones
cuerpo        ::= stmConstantes:stmConstantes stmTipos:stmTipos stmVar:stmVar stmSubprogram:stmSubprogram BEGIN sentencias:sentencias END IDENTIFICADOR PUNTOYCOMA
                {:
                  //Constants
                  for(ExpConst constant: stmConstantes.getSentConst().getExpConstList()){
                    checkSymbolDoesNotExists(constant.getIdentificador());
                    SymbolConstant symbolConstant = new SymbolConstant(getCurrentScope(), constant.getIdentificador(), new TypeSimple(getCurrentScope()));
                    addSymbol(constant.getIdentificador(), symbolConstant);
                  }

                  //Types TODO CONTINUAR
                  for(ExpConst constant: stmTipos.getSentTipo.getExpTipos()){
                    checkSymbolDoesNotExists(constant.getIdentificador());
                    SymbolTypoe symbolConstant = new SymbolConstant(getCurrentScope(), constant.getIdentificador(), new TypeSimple(getCurrentScope()));
                    addSymbol(constant.getIdentificador(), symbolConstant);
                  }

                   RESULT = new Cuerpo(stmConstantes, stmTipos, stmVar, stmSubprogram, sentencias);
                   closeCurrentScope();
                :}
                | stmConstantes stmTipos stmVar stmSubprogram BEGIN sentencias END error
                | stmConstantes stmTipos stmVar stmSubprogram BEGIN error;

// Reglas de producción para constantes
stmConstantes ::= CONST sentConst:sentConst
                  {:
                   RESULT = new StmConstantes(sentConst);
                  :}
                | // epsilon
                | CONST error;

sentConst     ::= sentConst:sentConst expConst:expConst
                  {:
                    sentConst.addExpConst(expConst);
                    RESULT = sentConst;
                  :}
                | expConst:expConst
                  {:
                     RESULT = new SentConst(expConst);
                  :};

expConst      ::= IDENTIFICADOR:identificador IGUAL valorConst:valorConst PUNTOYCOMA
                  {:
                   String expConstIdentificador = identificador.getLexema();
                   ExpConst expConst = new ExpConst(expConstIdentificador, valorConst);
                   RESULT = expConst;
                  :}
                 | IDENTIFICADOR error PUNTOYCOMA;

valorConst    ::= ENTERO:valor
                  {:
                   ValorConst valorConst = new ValorConst(Integer.parseInt(valor.getLexema()));
                   RESULT = valorConst;
                  :}
                | vBooleano:vBooleano
                  {:
                   ValorConst valorConst = new ValorConst(vBooleano.getValue());
                   RESULT = valorConst;
                  :};

// Reglas de producción para Tipos
stmTipos      ::= TYPE sentTipo:sentTipo
                {:
                  RESULT = new StmTipos(sentTipo);
                :}
                | // epsilon
                | TYPE error;

sentTipo      ::= sentTipo:sentTipo expTipo:expTipo
                {:
                    sentTipo.add(expTipo);
                    RESULT = sentTipo;
                :}
                | expTipo
                 {:
                    sentTipo.add(expTipo);
                    RESULT = new SentTipo(expTipo);
                 :};

expTipo       ::= IDENTIFICADOR:identificador IGUAL ARRAY CORCHIZQ entOid:endOidI PUNTOPUNTO entOid:endOidd CORCHDER OF intOBool:intOBool PUNTOYCOMA
                    {:
                        RESULT = new ExpTipo(identificador.getLexema(), endOidI, endOidd, intOBool);
                    :}
                | IDENTIFICADOR error PUNTOYCOMA;

// Reglas de producción para Variables
stmVar        ::= VAR sentVar:sentVar
                  {:
                    RESULT = new StmVar(sentVar);
                  :}
                | // epsilon
                | VAR error;

sentVar       ::= sentVar:sentVar expVar:expVar
                  {:
                     sentVar.addExpVar(expVar);
                     RESULT = sentVar;
                  :}
                  | expVar:expVar
                  {:
                    RESULT = new SentVar(expVar);
                  :};

expVar        ::= cadIdVar:cadIdVar DOSPUNTOS tipoVar:tipoVar PUNTOYCOMA
                  {:
                   RESULT = new ExpVar(cadIdVar, tipoVar);
                  :}
                | cadIdVar error PUNTOYCOMA;

cadIdVar      ::= IDENTIFICADOR:identificador COMA cadIdVar:cadIdVar
                 {:
                  cadIdVar.addIdentificador(identificador.getLexema());
                  RESULT = cadIdVar;
                 :}
                | IDENTIFICADOR:identificador
                {:
                  RESULT =  new CadIdVar(identificador.getLexema());
                :};

tipoVar       ::= intOBool:intOBool
                  {:
                    RESULT = new TipoVar(intOBool);
                  :}
                | IDENTIFICADOR:identificador
                  {:
                    RESULT = new TipoVar(identificador.getLexema());
                  :};

// Reglas de producción para Procedimientos y funciones
stmSubprogram  ::= cabProcedure:cabProcedure
                   cuerpo:cuerpo
                   stmSubprogram:stmSubprogram
                {:
                  stmSubprogram.addCuerpoAndProcedure(cuerpo, cabProcedure);
                  RESULT = stmSubprogram;
                :}
                | // epsilon
                ;
                
cabProcedure   ::= PROCEDURE IDENTIFICADOR:identificador procParenParam:procParenParam tipoRetorno:tipoRetorno PUNTOYCOMA
                  {:
                   openScope("PROCEDURE_"+identificador.getLexema());
                   RESULT = new CabProcedure(identificador.getLexema(), procParenParam, tipoRetorno);
                  :}
                |  PROCEDURE IDENTIFICADOR error 
                |  PROCEDURE error;

procParenParam ::= PARENIZQ procListParam:procListParam PARENDER
                {:
                 RESULT = new ProcParenParam(procListParam);
                :}
                | // epsilon
                ;

procListParam  ::= procParam:procParam PUNTOYCOMA procListParam:procListParam
                {:
                 procListParam.addProcParam(procParam);
                 RESULT = procListParam;
                :}
                |  procParam:procParam 
                {:
                 RESULT = new ProcListParam(procParam);
                :}
                |  // epsilon
                ;

procParam      ::= cadIdVar:cadIdVar DOSPUNTOS tipoVar:tipoVar
                {:
                  RESULT = new ProcParam(cadIdVar, tipoVar);
                :}
                |  cadIdVar error PUNTOYCOMA;

tipoRetorno    ::= DOSPUNTOS intOBool:intOBool
                  {:
                    RESULT = new TipoRetorno(intOBool);
                  :}
                |  // epsilon
                |  DOSPUNTOS error PUNTOYCOMA;

// expresion logicas y aritmeticas.
expresion     ::= exprArit
                | exprLogica
                | PARENIZQ expresion PARENDER
                | variables
                      ;

// Reglas de produccion para expresiones aritmeticas.
exprArit      ::= expresion MINUS expresion
                      
                | expresion PRODUCTO expresion
                      
                | ENTERO
                      ;

// Reglas de produccion para expresiones logicas.
exprLogica    ::= expresion MAYOR expresion
                      
                | expresion IGUAL expresion
                      
                | expresion OR expresion
                      
                | NOT expresion
                      
                | vBooleano
                      ;

// Reglas para sentencias.
sentencias    ::= listSentencia PUNTOYCOMA
                      
                | listSentencia
                       
                |  // epsilon
                      ;  // epsilon

listSentencia ::= listSentencia PUNTOYCOMA sentencia
                      
                | sentencia
                      ;

sentencia     ::= sentAsign
                      
                | sentIf
                      
                | sentFor
                      
                | sentReturn
                      
                | sWriteString
                      
                | sWriteInt
                      
                | sWriteLn
                      
                | sentProcedure
                      ;

// Sentencias Return
sentReturn     ::= RETURN expresion
                      
                |  RETURN error PUNTOYCOMA  
                      ;

// Sentencias de Asignacion
sentAsign     ::= variables DOSPUNTOSIGUAL expresion
                      
                | variables error PUNTOYCOMA 
                      ;
                      
// Sentencia IF-ELSE
sentIf        ::= IF expresion THEN sentencias sentElse END
                      
                | IF expresion error
                      
                | IF error PUNTOYCOMA;
                      
sentElse      ::= ELSE sentencias
                      
                |  // epsilon
                      ;

// Sentencia FOR
sentFor       ::= FOR IDENTIFICADOR DOSPUNTOSIGUAL expresion TO expresion DO sentencias END
                      
                | FOR IDENTIFICADOR DOSPUNTOSIGUAL expresion TO expresion error PUNTOYCOMA 
                      
                | FOR error PUNTOYCOMA;

// Sentencia llamada Funcion o Procedimiento
sentProcedure ::= IDENTIFICADOR
                      
                | IDENTIFICADOR parFuncion;
                  
// Parametros de llamada a función
parFuncion    ::= PARENIZQ parametros PARENDER
                      
                | PARENIZQ PARENDER
                      
                | PARENIZQ error;

parametros    ::= parametros COMA expresion
                      
                | expresion;

// Sentencias de Salida.
sWriteString  ::= WRITESTRING PARENIZQ STRING PARENDER
                | WRITESTRING error PUNTOYCOMA;

sWriteInt     ::= WRITEINT PARENIZQ expresion PARENDER
                      
                | WRITEINT error PUNTOYCOMA;

sWriteLn      ::= WRITELN;

// Tipos Basicos
variables     ::= IDENTIFICADOR:identificador
                {:
                    RESULT = new Variables(identificador.getLexema());
                :}
                | IDENTIFICADOR idArray:idArray
                {:
                    RESULT = new Variables(idArray);
                :}
                | IDENTIFICADOR parFuncion:parFuncion
                 {:
                    RESULT = new Variables(parFuncion);
                 :};

idArray       ::= CORCHIZQ expresion:expresion CORCHDER
                {:
                    RESULT = new IdArray(expresion);
                :};

intOBool      ::= INTEGER     
                  {:
                    RESULT =  new IntOBool("INTEGER");
                  :} 
                | BOOLEAN
                  {:
                    RESULT =  new IntOBool("BOOL");
                  :};

entOid        ::= ENTERO:entero
                {:
                    RESULT = new EntOId(Integer.parseInt(entero.getLexema()));
                :}
                | IDENTIFICADOR:identificador
                {:
                    RESULT = new EntOId(identificador.getLexema());
                :};

// Constantes Booleanas.
vBooleano     ::= TRUE
                  {:
                   RESULT = new VBooleano(true);
                  :}
                  | FALSE
                  {:
                   RESULT = new VBooleano(false);
                  :};