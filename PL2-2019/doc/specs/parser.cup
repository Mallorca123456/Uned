package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;



// Declaración del código de usuario

action code   {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory();

	public void openScope(String scopeName) {
	    ScopeIF scope = scopeManager.openScope(scopeName);
        semanticErrorManager.semanticInfo("Opened " + scope);
	}

    public ScopeIF getCurrentScope(){
        return scopeManager.getCurrentScope();
    }

	public void closeCurrentScope() {
	    ScopeIF scope = scopeManager.getCurrentScope();
        scopeManager.closeScope();
        semanticErrorManager.semanticInfo("Close " + scope);
	}

	public void checkSymbolDoesNotExists(String identifier){
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF symbolTable = scope.getSymbolTable();
	    if(symbolTable.containsSymbol(identifier)){
            semanticErrorManager.semanticFatalError("Identificador ya utilizado");
		}
	}

	public void checkTypeDoesNotExists(String identifier){
	    ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF typeTable = scope.getTypeTable();
        if(typeTable.containsType(identifier)){
            semanticErrorManager.semanticFatalError("Tipo ya utilizado");
        }

        while(scope.getParentScope() != null){
           ScopeIF parentScope = scope.getParentScope();
           TypeTableIF parentTypeTable = parentScope.getTypeTable();
           if(typeTable.containsType(identifier)){
             semanticErrorManager.semanticFatalError("Tipo ya utilizado");
           }
        }
	}

    public TypeIF getType(String identifier) {
        	    ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF typeTable = scope.getTypeTable();
                System.out.println("Searching type " + identifier);
                TypeIF type = typeTable.getType(identifier);

                 if(type==null) {
                    while(scope.getParentScope() != null){
                          scope = scope.getParentScope();
                          typeTable = scope.getTypeTable();
                          type = typeTable.getType(identifier);
                          System.out.println("Searching type " + identifier);
                          if(type == null){
                            semanticErrorManager.semanticFatalError("Tipo no encontrado");
                          }
                    }
                 }


                return type;
        }

	public void addSymbol(String identifier, SymbolIF symbol){
	    ScopeIF scope = scopeManager.getCurrentScope();
        SymbolTableIF symbolTable = scope.getSymbolTable();
        symbolTable.addSymbol(identifier, symbol);
        semanticErrorManager.semanticInfo("Added symbol " + identifier + " in " + scope);
	}

	public void addType(String identifier, TypeIF type){
	    ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF typeTable = scope.getTypeTable();
        typeTable.addType(identifier, type);
        semanticErrorManager.semanticInfo("Added type " + identifier + " in " + scope);
	}

:}

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

	public void syntax_error(Symbol symbol)
	{
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError("Error sintactico", token);
	}

	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError("Error fatal", token);
	}
:}


//
// Declaración de terminales

//
terminal Token IDENTIFICADOR;
terminal Token INTEGER, BOOLEAN, STRING;
terminal Token ARRAY, OF;
terminal Token MODULE, BEGIN, END, PROCEDURE, RETURN;
terminal Token OR, NOT;
terminal Token CONST, TYPE, VAR;
terminal Token IF, ELSE, THEN, DO, FOR, TO;
terminal Token WRITESTRING, WRITEINT, WRITELN;

terminal Token PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;
terminal Token PUNTOPUNTO, COMA, PUNTOYCOMA, DOSPUNTOS, IGUAL;
terminal Token MINUS, PRODUCTO, MAYOR;
terminal Token DOSPUNTOSIGUAL;

terminal Token ENTERO;
terminal Token TRUE, FALSE;

//
// Declaración de no terminales
//
non terminal                     program;
non terminal   Axiom		     axiom;

non terminal   CabModule         cabModule;
non terminal   Cuerpo            cuerpo;

non terminal   StmConstantes     stmConstantes;
non terminal   StmTipos          stmTipos;
non terminal   StmVar            stmVar;
non terminal   StmSubprogram     stmSubprogram;

non terminal   SentConst         sentConst;
non terminal   ExpConst          expConst;
non terminal   ValorConst        valorConst;

non terminal   SentTipo          sentTipo;
non terminal   ExpTipo           expTipo;

non terminal   SentVar           sentVar;
non terminal   ExpVar            expVar;
non terminal   CadIdVar          cadIdVar;
non terminal   TipoVar           tipoVar;

non terminal   CabProcedure      cabProcedure;
non terminal   TipoRetorno       tipoRetorno;
non terminal   ProcParenParam    procParenParam;
non terminal   ProcListParam     procListParam;
non terminal   ProcParam         procParam;

non terminal   Sentencias        sentencias;
non terminal   ListSentencia     listSentencia;
non terminal   Sentencia         sentencia;

non terminal   Expresion         expresion;
non terminal   ExpArit           exprArit;
non terminal   ExprLogica        exprLogica;
non terminal   Variables         variables;

non terminal   SentProcedure     sentProcedure;
non terminal   ParFuncion        parFuncion;
non terminal   Parametros        parametros;

non terminal   SentAsign         sentAsign;
non terminal   SentReturn        sentReturn;
non terminal   SentIf            sentIf;
non terminal   SentElse          sentElse;
non terminal   SentFor           sentFor;

non terminal   SWriteString      sWriteString;
non terminal   SWriteInt         sWriteInt;
non terminal   SWriteLn          sWriteLn;

non terminal   IdArray           idArray;
non terminal   IntOBool          intOBool;
non terminal   EntOId            entOid;
non terminal   VBooleano         vBooleano;

// Declaración de relaciones de precedencia
precedence nonassoc MAYOR, IGUAL;
precedence left     MINUS, OR;
precedence left     PRODUCTO;
precedence right    NOT;

precedence left     PARENIZQ, PARENDER, CORCHIZQ, CORCHDER;

//
// Declaración de reglas de producción

start with program;

program ::=
  {:
      syntaxErrorManager.syntaxInfo("Starting parsing...");

  :}
  axiom:ax
  {:
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas

  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.

  		syntaxErrorManager.syntaxInfo("Parsing process ended.");
  :};


axiom ::= cabModule:cabModule
          cuerpo:cuerpo
          | cabModule error;

// Cabecera de los modulos
cabModule     ::= MODULE IDENTIFICADOR:identificador PUNTOYCOMA
                  {:

                   openScope("MODULE_" + identificador.getLexema());

                   //Add simple types
                   addType("boolean", new TypeSimple(getCurrentScope(), "boolean"));
                   addType("int", new TypeSimple(getCurrentScope(), "int"));

                   RESULT = new CabModule(identificador.getLexema());
                  :};

// Cuerpo de los modulos y comun para procedimientos y funciones
cuerpo        ::= stmConstantes:stmConstantes stmTipos:stmTipos stmVar:stmVar stmSubprogram:stmSubprogram BEGIN sentencias:sentencias END IDENTIFICADOR PUNTOYCOMA
                {:
                  //Constants
                  if(stmConstantes.getSentConst() != null){
                      for(ExpConst constant: stmConstantes.getSentConst().getExpConstList()){
                        checkSymbolDoesNotExists(constant.getIdentificador());
                        ValorConst valorConst = constant.getValorConst();
                        SymbolConstant symbolConstant = null;
                        if(valorConst.isBoolean()) {
                           symbolConstant = new SymbolConstant(getCurrentScope(), constant.getIdentificador(), valorConst.getBoolean(), getType("boolean"));
                        } else {
                           symbolConstant = new SymbolConstant(getCurrentScope(), constant.getIdentificador(), valorConst.getValue(), getType("int"));
                        }
                        addSymbol(constant.getIdentificador(), symbolConstant);
                      }
                  }

                  //Types
                  if(stmTipos.getSentTipo() != null){
                    for(ExpTipo expTipo: stmTipos.getSentTipo().getExpTipos()){
                       checkTypeDoesNotExists(expTipo.getIdentificador());
                       TypeIF type = new TypeArray(getCurrentScope(), expTipo.getIdentificador());
                       addType(expTipo.getIdentificador(), type);
                    }
                  }


                  //Variables TODO pending add value
                  if(stmVar.getSentVar() != null) {
                    for(ExpVar expVar: stmVar.getSentVar().getExpVars()){
                        //Check names are not duplicated and type exists
                        CadIdVar cadIdVar = expVar.getCadIdVar();
                        for(String identificadorVariable : cadIdVar.getIdentificadores()){
                             checkSymbolDoesNotExists(identificadorVariable);
                             SymbolIF symbolVariable = new SymbolVariable(getCurrentScope(),
                                identificadorVariable, getType(expVar.getTipoVar().getIdentificadorTipo()));
                             addSymbol(identificadorVariable, symbolVariable);
                        }
                    }
                  }


                  //Subprograms
                  for (CabProcedure procedure : stmSubprogram.getProcedures()) {
                        checkSymbolDoesNotExists(procedure.getIdentificador());
                        SymbolIF symbol  = null;
                        if(procedure.getTipoRetorno().getIntOBool() == null) {//Is function
                            symbol = new SymbolFunction(getCurrentScope(), procedure.getIdentificador(),
                            procedure, new TypeFunction(getCurrentScope()));
                        } else {
                            symbol = new SymbolProcedure(getCurrentScope(), procedure.getIdentificador(),
                            procedure, new TypeFunction(getCurrentScope()));
                        }
                        addSymbol(procedure.getIdentificador(), symbol);
                    }

                   RESULT = new Cuerpo(stmConstantes, stmTipos, stmVar, stmSubprogram, sentencias);
                   closeCurrentScope();
                :};

// Reglas de producción para constantes
stmConstantes ::= CONST sentConst:sentConst
                  {:
                   RESULT = new StmConstantes(sentConst);
                  :}
                |
                  {:
                   RESULT = new StmConstantes();
                  :};

sentConst     ::= sentConst:sentConst expConst:expConst
                  {:
                    sentConst.addExpConst(expConst);
                    RESULT = sentConst;
                  :}
                | expConst:expConst
                  {:
                     RESULT = new SentConst(expConst);
                  :};

expConst      ::= IDENTIFICADOR:identificador IGUAL valorConst:valorConst PUNTOYCOMA
                  {:
                   String expConstIdentificador = identificador.getLexema();
                   ExpConst expConst = new ExpConst(expConstIdentificador, valorConst);
                   RESULT = expConst;
                  :};

valorConst    ::= ENTERO:valor
                  {:
                   ValorConst valorConst = new ValorConst(Integer.parseInt(valor.getLexema()));
                   RESULT = valorConst;
                  :}
                | vBooleano:vBooleano
                  {:
                   ValorConst valorConst = new ValorConst(vBooleano.getValue());
                   RESULT = valorConst;
                  :};

// Reglas de producción para Tipos
stmTipos      ::= TYPE sentTipo:sentTipo
                {:
                  RESULT = new StmTipos(sentTipo);
                :}
                |
                {:
                    RESULT = new StmTipos();
                :};

sentTipo      ::= sentTipo:sentTipo expTipo:expTipo
                {:
                    sentTipo.addExpTipo(expTipo);
                    RESULT = sentTipo;
                :}
                | expTipo:expTipo
                 {:
                    RESULT = new SentTipo(expTipo);
                 :};

expTipo       ::= IDENTIFICADOR:identificador IGUAL ARRAY CORCHIZQ entOid:endOidI PUNTOPUNTO entOid:endOidd CORCHDER OF intOBool:intOBool PUNTOYCOMA
                    {:
                        RESULT = new ExpTipo(identificador.getLexema(), endOidI, endOidd, intOBool);
                    :};

// Reglas de producción para Variables
stmVar        ::= VAR sentVar:sentVar
                  {:
                    RESULT = new StmVar(sentVar);
                  :}
                |
                  {:
                    RESULT = new StmVar();
                  :};

sentVar       ::= sentVar:sentVar expVar:expVar
                  {:
                     sentVar.addExpVar(expVar);
                     RESULT = sentVar;
                  :}
                  | expVar:expVar
                  {:
                    RESULT = new SentVar(expVar);
                  :};

expVar        ::= cadIdVar:cadIdVar DOSPUNTOS tipoVar:tipoVar PUNTOYCOMA
                  {:
                   RESULT = new ExpVar(cadIdVar, tipoVar);
                  :};

cadIdVar      ::= IDENTIFICADOR:identificador COMA cadIdVar:cadIdVar
                 {:
                  cadIdVar.addIdentificador(identificador.getLexema());
                  RESULT = cadIdVar;
                 :}
                | IDENTIFICADOR:identificador
                {:
                  RESULT =  new CadIdVar(identificador.getLexema());
                :};

tipoVar       ::= intOBool:intOBool
                  {:
                    RESULT = new TipoVar(intOBool);
                  :}
                | IDENTIFICADOR:identificador
                  {:
                    RESULT = new TipoVar(identificador.getLexema());
                  :};

// Reglas de producción para Procedimientos y funciones
stmSubprogram  ::= cabProcedure:cabProcedure
                   cuerpo:cuerpo
                   stmSubprogram:stmSubprogram
                {:
                  stmSubprogram.addCuerpoAndProcedure(cuerpo, cabProcedure);
                  RESULT = stmSubprogram;
                :}
                |
                {:
                   RESULT = new StmSubprogram();
                :};
                
cabProcedure   ::= PROCEDURE IDENTIFICADOR:identificador procParenParam:procParenParam tipoRetorno:tipoRetorno PUNTOYCOMA
                  {:
                   openScope("PROCEDURE_"+identificador.getLexema());
                   RESULT = new CabProcedure(identificador.getLexema(), procParenParam, tipoRetorno);
                  :};

procParenParam ::= PARENIZQ procListParam:procListParam PARENDER
                {:
                 RESULT = new ProcParenParam(procListParam);
                :}
                |
                {:
                 RESULT = new ProcParenParam();
                :};

procListParam  ::= procParam:procParam PUNTOYCOMA procListParam:procListParam
                {:
                 procListParam.addProcParam(procParam);
                 RESULT = procListParam;
                :}
                |  procParam:procParam 
                {:
                 RESULT = new ProcListParam(procParam);
                :}
                |
                {:
                    RESULT = new ProcListParam();
                :};

procParam      ::= cadIdVar:cadIdVar DOSPUNTOS tipoVar:tipoVar
                {:
                  RESULT = new ProcParam(cadIdVar, tipoVar);
                :};

tipoRetorno    ::= DOSPUNTOS intOBool:intOBool
                  {:
                    RESULT = new TipoRetorno(intOBool);
                  :}
                |
                 {:
                   RESULT = new TipoRetorno();
                 :};

// expresion logicas y aritmeticas.
expresion     ::= exprArit
                | exprLogica
                | PARENIZQ expresion PARENDER
                | variables;

// Reglas de produccion para expresiones aritmeticas.
exprArit      ::= expresion MINUS expresion
                | expresion PRODUCTO expresion
                | ENTERO;

// Reglas de produccion para expresiones logicas.
exprLogica    ::= expresion MAYOR expresion
                | expresion IGUAL expresion
                | expresion OR expresion
                | NOT expresion
                | vBooleano
                      ;

// Reglas para sentencias.
sentencias    ::= listSentencia:listSentencia PUNTOYCOMA
                {:
                   RESULT = new Sentencias(listSentencia);
                :}
                | listSentencia:listSentencia
                {:
                   RESULT = new Sentencias(listSentencia);
                :}
                |
                {:
                  RESULT = new Sentencias();
                :};

listSentencia ::= listSentencia:listSentencia PUNTOYCOMA sentencia:sentencia
                {:
                    listSentencia.addSentencia(sentencia);
                :}
                | sentencia:sentencia
                {:
                    RESULT = new ListSentencia(sentencia);
                :};

sentencia     ::= sentAsign:sentAsign
                 {:
                    RESULT = new Sentencia(sentAsign);
                 :}
                | sentIf:sentIf
                {:
                  RESULT = new Sentencia(sentIf);
                :}
                | sentFor:sentFor
                {:
                  RESULT = new Sentencia(sentFor);
                :}
                | sentReturn:sentReturn
                {:
                  RESULT = new Sentencia(sentReturn);
                :}
                | sWriteString:sWriteString
                {:
                  RESULT = new Sentencia(sWriteString);
                :}
                | sWriteInt:sWriteInt
                {:
                  RESULT = new Sentencia(sWriteInt);
                :}
                | sWriteLn:sWriteLn
                {:
                  RESULT = new Sentencia(sWriteLn);
                :}
                | sentProcedure:sentProcedure
                {:
                  RESULT = new Sentencia(sentProcedure);
                :};

// Sentencias Return
sentReturn     ::= RETURN expresion:expresion
                {:
                   RESULT = new SentReturn(expresion);
                :};

// Sentencias de Asignacion
sentAsign     ::= variables:variables DOSPUNTOSIGUAL expresion:expresion
                {:
                 RESULT = new SentAsign(variables, expresion);
                :};
                      
// Sentencia IF-ELSE
sentIf        ::= IF expresion:expresion THEN sentencias:sentencias sentElse:sentElse END
                {:
                  RESULT = new SentIf(expresion, sentencias, sentElse);

                :};
sentElse      ::= ELSE sentencias:sentencias
                {:
                   RESULT = new SentElse(sentencias);
                :}
                |
                {:
                   RESULT = new SentElse();
                :};

// Sentencia FOR
sentFor       ::= FOR IDENTIFICADOR:identificador DOSPUNTOSIGUAL expresion:expresionFrom TO expresion:expresionTo DO sentencias:sentencias END
                {:
                   RESULT = new SentFor(identificador.getLexema(), expresionFrom, expresionTo, sentencias);
                :};

// Sentencia llamada Funcion o Procedimiento
sentProcedure ::= IDENTIFICADOR:identificador
                {:
                 RESULT = new SentProcedure(identificador.getLexema());
                :}
                | IDENTIFICADOR:identificador parFuncion:parFuncion
                {:
                    RESULT = new SentProcedure(identificador.getLexema(), parFuncion);
                :};
                  
// Parametros de llamada a función
parFuncion    ::= PARENIZQ parametros:parametros PARENDER
                {:
                   RESULT = new ParFuncion(parametros);
                :}
                | PARENIZQ PARENDER
                {:
                   RESULT = new ParFuncion();
                :};

parametros    ::= parametros:parametros COMA expresion:expresion
                {:
                    parametros.addExpresion(expresion);
                    RESULT = parametros;
                :}
                | expresion:expresion
                {:
                    RESULT = new Parametros(expresion);
                :};

// Sentencias de Salida.
sWriteString  ::= WRITESTRING PARENIZQ STRING:string PARENDER
                {:
                    RESULT = new SWriteString(string.getLexema());
                :};

sWriteInt     ::= WRITEINT PARENIZQ expresion:expresion PARENDER
                {:
                    RESULT = new SWriteInt(expresion);
                :};

sWriteLn      ::= WRITELN
                {:
                RESULT = new SWriteLn();
                :};

// Tipos Basicos
variables     ::= IDENTIFICADOR:identificador
                  {:
                    RESULT = new Variables(identificador.getLexema());
                  :}
                | IDENTIFICADOR idArray:idArray
                  {:
                    RESULT = new Variables(idArray);
                  :}
                | IDENTIFICADOR parFuncion:parFuncion
                 {:
                    RESULT = new Variables(parFuncion);
                 :};

idArray       ::= CORCHIZQ expresion:expresion CORCHDER
                  {:
                    RESULT = new IdArray(expresion);
                  :};

intOBool      ::= INTEGER     
                  {:
                    RESULT =  new IntOBool("INTEGER");
                  :} 
                | BOOLEAN
                  {:
                    RESULT =  new IntOBool("BOOL");
                  :};

entOid        ::= ENTERO:entero
                  {:
                    RESULT = new EntOId(Integer.parseInt(entero.getLexema()));
                  :}
                | IDENTIFICADOR:identificador
                  {:
                    RESULT = new EntOId(identificador.getLexema());
                  :};

// Constantes Booleanas.
vBooleano     ::= TRUE
                  {:
                   RESULT = new VBooleano(true);
                  :}
                  | FALSE
                  {:
                   RESULT = new VBooleano(false);
                  :};